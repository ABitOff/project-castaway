struct Foo { a : :: std :: string :: String , b : & 'static [:: std :: primitive :: u8] , c : Bar , d : a :: b :: Enum , e : :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > , a2 : :: std :: option :: Option < :: std :: string :: String > , b2 : :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , c2 : :: std :: option :: Option < Bar > , d2 : :: std :: option :: Option < a :: b :: Enum > , e2 : :: std :: option :: Option < :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > > , a3 : :: std :: string :: String , b3 : & 'static [:: std :: primitive :: u8] , d3 : a :: b :: Enum , a_e : :: std :: option :: Option < :: std :: string :: String > , b_e : :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , c_e : :: std :: option :: Option < Bar > , d_e : :: std :: option :: Option < a :: b :: Enum > , e_e : :: std :: option :: Option < :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > > } impl :: syn :: parse :: Parse for Foo { fn parse (input : :: syn :: parse :: ParseStream) -> :: syn :: Result < Self > { let mut group_0 = false ; let mut group_1 = false ; let mut group_2 = false ; let mut group_3 = false ; let mut group_4 = false ; let mut group_5 = false ; let mut group_6 = false ; let mut group_7 = false ; let mut group_8 = false ; let mut group_9 = false ; let mut group_10 = false ; let mut group_11 = false ; let mut group_12 = false ; let mut group_13 = false ; let mut field_tracker : (:: std :: option :: Option < :: std :: string :: String > , :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , :: std :: option :: Option < Bar > , :: std :: option :: Option < a :: b :: Enum > , :: std :: option :: Option < :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > > , :: std :: option :: Option < :: std :: string :: String > , :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , :: std :: option :: Option < Bar > , :: std :: option :: Option < a :: b :: Enum > , :: std :: option :: Option < :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > > , :: std :: option :: Option < :: std :: string :: String > , :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , :: std :: option :: Option < a :: b :: Enum > , :: std :: option :: Option < :: std :: string :: String > , :: std :: option :: Option < & 'static [:: std :: primitive :: u8] > , :: std :: option :: Option < Bar > , :: std :: option :: Option < a :: b :: Enum > , :: std :: option :: Option < :: std :: collections :: BTreeMap < :: std :: string :: String , :: std :: string :: String > >) = (:: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: Some ("ABC123" . to_string ()) , :: std :: option :: Option :: Some (b"123abc\x00") , :: std :: option :: Option :: Some (a :: b :: Enum :: B) , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None , :: std :: option :: Option :: None) ; let brace = :: syn :: __private :: parse_braces (& input) ? ; let content = brace . content ; while ! content . is_empty () { let ident = content . parse :: < :: syn :: Ident > () ? ; let field_name = ident . to_string () ; match field_name . as_str () { "a" => { if group_0 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "a"))) ; } group_0 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 0 = Some ({ content . parse :: < :: syn :: LitStr > () ? . value () }) ; } "b" => { if group_1 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "b"))) ; } group_1 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 1 = Some ({ content . parse :: < :: syn :: LitByteStr > () ? . value () . leak () }) ; } "c" => { if group_2 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "c"))) ; } group_2 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 2 = Some ({ content . parse :: < Bar > () ? }) ; } "d" => { if group_3 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "d"))) ; } group_3 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 3 = Some ({ let ident = content . parse :: < :: syn :: Ident > () ? ; let ident_string = ident . to_string () ; match ident_string . as_str () { "A" => a :: b :: Enum :: A , "B" => a :: b :: Enum :: B , "C" => a :: b :: Enum :: C , _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Must be one of the following: {}" , "A, B, C"))) ; } } }) ; } "e" => { if group_4 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "e"))) ; } group_4 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 4 = Some ({ let mut map = :: std :: collections :: BTreeMap :: < :: std :: string :: String , :: std :: string :: String > :: new () ; let brace = :: syn :: __private :: parse_braces (& content) ? ; let content = brace . content ; while ! content . is_empty () { let key = content . parse :: < :: syn :: Ident > () ? ; let colon = content . parse :: < :: syn :: token :: Colon > () ? ; let value = content . parse :: < :: syn :: LitStr > () ? ; map . insert (key . to_string () , value . value ()) ; if content . is_empty () { break ; } content . parse :: < :: syn :: token :: Comma > () ? ; } map }) ; } "a2" => { if group_5 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "a2"))) ; } group_5 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 5 = Some ({ content . parse :: < :: syn :: LitStr > () ? . value () }) ; } "b2" => { if group_6 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "b2"))) ; } group_6 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 6 = Some ({ content . parse :: < :: syn :: LitByteStr > () ? . value () . leak () }) ; } "c2" => { if group_7 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "c2"))) ; } group_7 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 7 = Some ({ content . parse :: < Bar > () ? }) ; } "d2" => { if group_8 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "d2"))) ; } group_8 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 8 = Some ({ let ident = content . parse :: < :: syn :: Ident > () ? ; let ident_string = ident . to_string () ; match ident_string . as_str () { "A" => a :: b :: Enum :: A , "B" => a :: b :: Enum :: B , "C" => a :: b :: Enum :: C , _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Must be one of the following: {}" , "A, B, C"))) ; } } }) ; } "e2" => { if group_9 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "e2"))) ; } group_9 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 9 = Some ({ let mut map = :: std :: collections :: BTreeMap :: < :: std :: string :: String , :: std :: string :: String > :: new () ; let brace = :: syn :: __private :: parse_braces (& content) ? ; let content = brace . content ; while ! content . is_empty () { let key = content . parse :: < :: syn :: Ident > () ? ; let colon = content . parse :: < :: syn :: token :: Colon > () ? ; let value = content . parse :: < :: syn :: LitStr > () ? ; map . insert (key . to_string () , value . value ()) ; if content . is_empty () { break ; } content . parse :: < :: syn :: token :: Comma > () ? ; } map }) ; } "a3" => { if group_10 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "a3"))) ; } group_10 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 10 = Some ({ content . parse :: < :: syn :: LitStr > () ? . value () }) ; } "b3" => { if group_11 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "b3"))) ; } group_11 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 11 = Some ({ content . parse :: < :: syn :: LitByteStr > () ? . value () . leak () }) ; } "d3" => { if group_12 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "d3"))) ; } group_12 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 12 = Some ({ let ident = content . parse :: < :: syn :: Ident > () ? ; let ident_string = ident . to_string () ; match ident_string . as_str () { "A" => a :: b :: Enum :: A , "B" => a :: b :: Enum :: B , "C" => a :: b :: Enum :: C , _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Must be one of the following: {}" , "A, B, C"))) ; } } }) ; } "a_e" => { if group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("There can only be one of the following fields: {}" , "a_e, b_e, c_e, d_e, e_e"))) ; } group_13 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 13 = Some ({ content . parse :: < :: syn :: LitStr > () ? . value () }) ; } "b_e" => { if group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("There can only be one of the following fields: {}" , "a_e, b_e, c_e, d_e, e_e"))) ; } group_13 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 14 = Some ({ content . parse :: < :: syn :: LitByteStr > () ? . value () . leak () }) ; } "c_e" => { if group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("There can only be one of the following fields: {}" , "a_e, b_e, c_e, d_e, e_e"))) ; } group_13 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 15 = Some ({ content . parse :: < Bar > () ? }) ; } "d_e" => { if group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("There can only be one of the following fields: {}" , "a_e, b_e, c_e, d_e, e_e"))) ; } group_13 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 16 = Some ({ let ident = content . parse :: < :: syn :: Ident > () ? ; let ident_string = ident . to_string () ; match ident_string . as_str () { "A" => a :: b :: Enum :: A , "B" => a :: b :: Enum :: B , "C" => a :: b :: Enum :: C , _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Must be one of the following: {}" , "A, B, C"))) ; } } }) ; } "e_e" => { if group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("There can only be one of the following fields: {}" , "a_e, b_e, c_e, d_e, e_e"))) ; } group_13 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 17 = Some ({ let mut map = :: std :: collections :: BTreeMap :: < :: std :: string :: String , :: std :: string :: String > :: new () ; let brace = :: syn :: __private :: parse_braces (& content) ? ; let content = brace . content ; while ! content . is_empty () { let key = content . parse :: < :: syn :: Ident > () ? ; let colon = content . parse :: < :: syn :: token :: Colon > () ? ; let value = content . parse :: < :: syn :: LitStr > () ? ; map . insert (key . to_string () , value . value ()) ; if content . is_empty () { break ; } content . parse :: < :: syn :: token :: Comma > () ? ; } map }) ; } _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Unexpected field: {}" , field_name))) ; } } if content . is_empty () { break ; } content . parse :: < :: syn :: token :: Comma > () ? ; } if let :: std :: option :: Option :: None = field_tracker . 0 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "a"))) ; } if let :: std :: option :: Option :: None = field_tracker . 1 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "b"))) ; } if let :: std :: option :: Option :: None = field_tracker . 2 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "c"))) ; } if let :: std :: option :: Option :: None = field_tracker . 3 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "d"))) ; } if let :: std :: option :: Option :: None = field_tracker . 4 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "e"))) ; } if let :: std :: option :: Option :: None = field_tracker . 5 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "a2"))) ; } if let :: std :: option :: Option :: None = field_tracker . 6 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "b2"))) ; } if let :: std :: option :: Option :: None = field_tracker . 7 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "c2"))) ; } if let :: std :: option :: Option :: None = field_tracker . 8 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "d2"))) ; } if let :: std :: option :: Option :: None = field_tracker . 9 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "e2"))) ; } if let :: std :: option :: Option :: None = field_tracker . 10 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "a3"))) ; } if let :: std :: option :: Option :: None = field_tracker . 11 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "b3"))) ; } if let :: std :: option :: Option :: None = field_tracker . 12 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "d3"))) ; } if ! group_13 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("Exactly one of {} is required." , "a_e, b_e, c_e, d_e, e_e"))) ; } Ok (Self { a : field_tracker . 0 . unwrap () , b : field_tracker . 1 . unwrap () , c : field_tracker . 2 . unwrap () , d : field_tracker . 3 . unwrap () , e : field_tracker . 4 . unwrap () , a2 : field_tracker . 5 , b2 : field_tracker . 6 , c2 : field_tracker . 7 , d2 : field_tracker . 8 , e2 : field_tracker . 9 , a3 : field_tracker . 10 . unwrap () , b3 : field_tracker . 11 . unwrap () , d3 : field_tracker . 12 . unwrap () , a_e : field_tracker . 13 , b_e : field_tracker . 14 , c_e : field_tracker . 15 , d_e : field_tracker . 16 , e_e : field_tracker . 17 }) } } struct Bar { bar : :: std :: string :: String } impl :: syn :: parse :: Parse for Bar { fn parse (input : :: syn :: parse :: ParseStream) -> :: syn :: Result < Self > { let mut group_0 = false ; let mut field_tracker : (:: std :: option :: Option < :: std :: string :: String >) = (:: std :: option :: Option :: None) ; let brace = :: syn :: __private :: parse_braces (& input) ? ; let content = brace . content ; while ! content . is_empty () { let ident = content . parse :: < :: syn :: Ident > () ? ; let field_name = ident . to_string () ; match field_name . as_str () { "bar" => { if group_0 { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Duplicate field: {}" , "bar"))) ; } group_0 = true ; content . parse :: < :: syn :: token :: Colon > () ? ; field_tracker . 0 = Some ({ content . parse :: < :: syn :: LitStr > () ? . value () }) ; } _ => { return :: std :: result :: Result :: Err (:: syn :: Error :: new_spanned (ident , :: std :: format ! ("Unexpected field: {}" , field_name))) ; } } if content . is_empty () { break ; } content . parse :: < :: syn :: token :: Comma > () ? ; } if let :: std :: option :: Option :: None = field_tracker . 0 { return :: std :: result :: Result :: Err (:: syn :: Error :: new (:: proc_macro2 :: Span :: call_site () , :: std :: format ! ("{} is a required field." , "bar"))) ; } Ok (Self { bar : field_tracker . 0 . unwrap () }) } }